#!/bin/env python3.4
# vim: expandtab:tabstop=4:shiftwidth=4

""" Listen for kubernetes PLEG creation events, and launch an
    image-inspector scan for every newly created customer container. """

from datetime import datetime, timedelta

import json
import os
import socket
import subprocess
import re
import requests
import yaml

#from Queue import Queue
#from threading import Thread

# pylint: disable=line-too-long
class PlegEventListener(object):
    """ Class to receive and report scan results. """

# get number of items in worker queue and launch scan if none incoming?
#    def scan_worker(self, scan_q):
#        """ This is the worker thread function. """
#        while True:
#            container = scan_q.get()
#            self.process_container(container)
#            scan_q.task_done()


#    def scan_worker():
#        """ This is the worker thread function. """
#        print("listener, gonna send container off for scanning")
#        # add container id and function to process it here
#        scan_q.put(container_id)
#        #self.process_container(container_id)

    # pylint: disable=too-many-locals
    def gather_images(self):
        """ Gather and filter registry images. """

        reg_cmd = ['chroot', \
                   '/host', \
                   'oc', \
                   'get', \
                   'service', \
                   '-n', \
                   'default', \
                   'docker-registry', \
                   '--template=\'{{index .spec "clusterIP"}}:{{(index .spec.ports 0).port}}\''
                  ]

        reg_add = subprocess.check_output(reg_cmd).strip('\'').strip('\"')

        rh_con_reg = r'(^registry.connect.redhat.com)|'
        rh_acc_reg = r'(^registry.access.redhat.com)|'
        rh_io_reg = r'(^registry.redhat.io)|'
        reg_aws = r'(^registry.reg-aws.openshift.com)'
        priv_ns = r'(^' + reg_add + r'\/openshift-)'
        heal_ns = r'(^' + reg_add + \
        r'\/ops-health-monitoring\/)|(^docker-registry.default.svc:5000\/ops-health-monitoring\/)'

        print(reg_add)
        print(priv_ns)

        img_list = subprocess.check_output(\
        ['oc', 'get', 'images', '--no-headers=true']
                                          ).splitlines()

        for imname in img_list:
            im_id = imname.split()[0]
            im_add = imname.split()[1]
            is_health = re.match(heal_ns, im_add, re.I)
            is_rh = re.match(rh_con_reg + rh_acc_reg + rh_io_reg + reg_aws, im_add, re.I)
            is_ops = re.match(priv_ns, im_add, re.I)

            if not is_health and not is_rh and not is_ops:
                self.process_image(im_add, im_id)


    @staticmethod
    def process_image(im_add, im_id):
        """ Scan the provided image. """

        img_cmd = ['oc', \
       'export', \
       'image',
                   im_id, \
        '--template=\
        \'{{with .metadata.annotations.scanned}}{{.}} {{else}}never-scanned {{end}}{{.metadata.name}}\'' \
                  ]

        img_output = subprocess.check_output(img_cmd).strip('\'').strip('\"')
        print(img_output)
        podstamp = img_output.split()[0]

        if podstamp == 'never-scanned' or \
        datetime.today()-timedelta(weeks=2) > \
        datetime.strptime(podstamp, '%Y%m%d'):

            curdate = datetime.now().strftime('%Y%m%d')

            anno_cmd = ['chroot', \
                        '/host', \
                        'oc', \
                        'annotate', \
                        'image', \
                        im_id, \
                        'scanned=' + curdate, \
                        '--overwrite'
                       ]
            subprocess.call(anno_cmd)

            scan_cmd = ['chroot', \
                        '/host', \
                        'image-inspector', \
                        '-scan-type=clamav', \
                        '-clam-socket=/host/host/var/run/clamd.scan/clamd.sock', \
                        '-image=' + im_add, \
                        '-post-results-url=http://localhost:8080', \
                        '--path=/tmp/image-content'
                       ]
            print(scan_cmd)
            subprocess.call(scan_cmd)
            # todo: catch errors with the image-inspector command and de-annotate if there was an issue?


    @staticmethod
    def get_api_info(config_path):
        """ Get info about the API that can be used to call the deprovisioner

            Returns:
                A dictionary with the address and token for the manage.openshift.com API.
         """

        config_settings = {}

        if os.path.isfile(config_path):
            with open(config_path, 'r') as log_config:
                yaml_config = yaml.load(log_config)

                try:
                    config_settings['occ_api_token'] = yaml_config['occ_api_token']
                except KeyError:
                    pass

                try:
                    config_settings['occ_api_url'] = yaml_config['occ_api_url']
                except KeyError:
                    pass

        return config_settings


    @staticmethod
    def load_sigs():
        """ Get the dictionary of signatures to match.

            Any container hosting code matched by these signatures should have
            its user be called for deprovisioning as soon as they are detected.

            Returns:
                A dictionary containing signatures of especially disruptive code.
        """

        sigs_path = '/secrets/takedown_sigs.yml'

        sig_dict = {}

        if os.path.isfile(sigs_path):
            with open(sigs_path, 'r') as sig_config:
                yaml_config = yaml.load(sig_config)

                if yaml_config['Immediate_Takedown']:
                    sig_dict = yaml_config['Immediate_Takedown']

        return sig_dict


    def convert_types(self, data):
        """ Used to convert dicts of bytes received as json.

            Returns:
                a dict of strings
                a string converted from bytes
         """

        if isinstance(data, bytes):
            return data.decode('ascii')
        if isinstance(data, dict):
            return dict(map(self.convert_types, data.items()))
        if isinstance(data, tuple):
            return map(self.convert_types, data)
        return data


    # pylint: disable=too-many-nested-blocks
    def start_serve(self, sig_dict, api_info):
        """ Listen on specified port for incoming clam logs. """

        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        host = socket.gethostname()

        server_address = (host, 8080)
        sock.bind(server_address)

        sock.listen(1)

        while True:
            connection, _ = sock.accept()

            try:
                while True:
                    # pylint: disable=no-member
                    data = connection.recv(10240)

                    print(type(data))
                    print(data)

                    newdata = data.split(b'\r\n\r\n')[1].strip(b"'")

                    conv_js = self.convert_types(newdata)

                    try:
                        rec_js = json.loads(conv_js)
                    except ValueError:
                        rec_js = conv_js

                    if isinstance(rec_js, dict) and 'results' not in rec_js:
                        break

                    else:
                        for sig_res in rec_js['results']:
                            sig_msg = sig_res['description']
                            sig_name, reason_code = sig_msg.split()

                            pod_ns = rec_js['nameSpace'].strip('\'').strip('\"')

                            reserved_ns = re.match(r'(^openshift-)', pod_ns, re.I)
                            default_ns = re.match(r'(^default$)', pod_ns, re.I)

                            if not reserved_ns and not default_ns and sig_name in sig_dict:
                                self.deprovision(api_info, pod_ns, reason_code)

                        break

            finally:
                connection.close()


    @staticmethod
    def deprovision(api_info, pod_ns, reason_code):
        """ Call the deprovisioner API for a full takedown. """


        api_token = api_info['occ_api_token']
        api_url = api_info['occ_api_url']

        des_proj_cmd = ['chroot', \
                        '/host', \
                        'oc', \
                        'export', \
                        'project', \
                         pod_ns, \
                        '--template='\
                        '{{index .metadata.annotations "openshift.io/requester"}}\'' \
                       ]

        user_name = subprocess.check_output(des_proj_cmd).strip(b'\'').strip(b'\"')

        devtools_acc = re.match(r'(^devtools-sre$)', user_name, re.I)

        if devtools_acc:
            anno_cmd = ['chroot', \
                        '/host', \
                        'oc', \
                        'annotate', \
                        'namespace',
                        pod_ns, \
                        'takedown=True', \
                        '--overwrite'
                       ]
            subprocess.call(anno_cmd)

        else:
            api_url += user_name + '/ban'
            headers = {'Authorization': 'Bearer ' + api_token}
            put_data = {'is_banned': 'true', 'takedown_code': reason_code}
            new_req = requests.put(api_url, data=put_data, headers=headers)

            print(new_req.status_code, new_req.reason)


    def main(self):
        """ Main function. """
#        self.gather_images()

        api_info = self.get_api_info('/secrets/api_config.yml')
        sig_dict = self.load_sigs()
        self.start_serve(sig_dict, api_info)
#        scan_q = Queue()
#        worker = Thread(target=self.scan_worker, args=(scan_q,))
#        worker.setDaemon(True)
#        worker.start()

        #self.(scan_q)


if __name__ == '__main__':
    EVENTLISTENER = PlegEventListener()
    EVENTLISTENER.main()
